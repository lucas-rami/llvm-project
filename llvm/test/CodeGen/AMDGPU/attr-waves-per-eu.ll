; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -mtriple=amdgcn-unknown-unknown -mcpu=tahiti -passes=amdgpu-promote-alloca -disable-promote-alloca-to-vector < %s | FileCheck %s

; Both of these kernels have the same value for
; amdgpu-flat-work-group-size, except one explicitly sets it. This is
; a program visible property which should always take precedence over
; the amdgpu-waves-per-eu optimization hint.
;
; The range is incompatible with the amdgpu-waves-per-eu value, so the
; flat work group size should take precedence implying a requirement
; to support 1024 size workgroups (which exceeds the available LDS
; amount).

define amdgpu_kernel void @no_flat_workgroup_size(ptr addrspace(1) nocapture %out, ptr addrspace(1) nocapture %in) #0 {
; CHECK-LABEL: @no_flat_workgroup_size(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = call range(i32 0, 1025) i32 @llvm.r600.read.local.size.y()
; CHECK-NEXT:    [[TMP1:%.*]] = call range(i32 0, 1025) i32 @llvm.r600.read.local.size.z()
; CHECK-NEXT:    [[TMP2:%.*]] = call range(i32 0, 1024) i32 @llvm.amdgcn.workitem.id.x()
; CHECK-NEXT:    [[TMP3:%.*]] = call range(i32 0, 1024) i32 @llvm.amdgcn.workitem.id.y()
; CHECK-NEXT:    [[TMP4:%.*]] = call range(i32 0, 1024) i32 @llvm.amdgcn.workitem.id.z()
; CHECK-NEXT:    [[TMP5:%.*]] = mul nuw nsw i32 [[TMP0]], [[TMP1]]
; CHECK-NEXT:    [[TMP6:%.*]] = mul i32 [[TMP5]], [[TMP2]]
; CHECK-NEXT:    [[TMP7:%.*]] = mul nuw nsw i32 [[TMP3]], [[TMP1]]
; CHECK-NEXT:    [[TMP8:%.*]] = add i32 [[TMP6]], [[TMP7]]
; CHECK-NEXT:    [[TMP9:%.*]] = add i32 [[TMP8]], [[TMP4]]
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr inbounds [1024 x [5 x i32]], ptr addrspace(3) @no_flat_workgroup_size.stack, i32 0, i32 [[TMP9]]
; CHECK-NEXT:    [[TMP11:%.*]] = load i32, ptr addrspace(1) [[IN:%.*]], align 4
; CHECK-NEXT:    [[ARRAYIDX1:%.*]] = getelementptr inbounds [5 x i32], ptr addrspace(3) [[TMP10]], i32 0, i32 [[TMP11]]
; CHECK-NEXT:    store i32 4, ptr addrspace(3) [[ARRAYIDX1]], align 4
; CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds i32, ptr addrspace(1) [[IN]], i32 1
; CHECK-NEXT:    [[TMP12:%.*]] = load i32, ptr addrspace(1) [[ARRAYIDX2]], align 4
; CHECK-NEXT:    [[ARRAYIDX3:%.*]] = getelementptr inbounds [5 x i32], ptr addrspace(3) [[TMP10]], i32 0, i32 [[TMP12]]
; CHECK-NEXT:    store i32 5, ptr addrspace(3) [[ARRAYIDX3]], align 4
; CHECK-NEXT:    [[TMP13:%.*]] = load i32, ptr addrspace(3) [[TMP10]], align 4
; CHECK-NEXT:    store i32 [[TMP13]], ptr addrspace(1) [[OUT:%.*]], align 4
; CHECK-NEXT:    [[ARRAYIDX12:%.*]] = getelementptr inbounds [5 x i32], ptr addrspace(3) [[TMP10]], i32 0, i32 1
; CHECK-NEXT:    [[TMP14:%.*]] = load i32, ptr addrspace(3) [[ARRAYIDX12]], align 4
; CHECK-NEXT:    [[ARRAYIDX13:%.*]] = getelementptr inbounds i32, ptr addrspace(1) [[OUT]], i32 1
; CHECK-NEXT:    store i32 [[TMP14]], ptr addrspace(1) [[ARRAYIDX13]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %stack = alloca [5 x i32], align 4, addrspace(5)
  %0 = load i32, ptr addrspace(1) %in, align 4
  %arrayidx1 = getelementptr inbounds [5 x i32], ptr addrspace(5) %stack, i32 0, i32 %0
  store i32 4, ptr addrspace(5) %arrayidx1, align 4
  %arrayidx2 = getelementptr inbounds i32, ptr addrspace(1) %in, i32 1
  %1 = load i32, ptr addrspace(1) %arrayidx2, align 4
  %arrayidx3 = getelementptr inbounds [5 x i32], ptr addrspace(5) %stack, i32 0, i32 %1
  store i32 5, ptr addrspace(5) %arrayidx3, align 4
  %2 = load i32, ptr addrspace(5) %stack, align 4
  store i32 %2, ptr addrspace(1) %out, align 4
  %arrayidx12 = getelementptr inbounds [5 x i32], ptr addrspace(5) %stack, i32 0, i32 1
  %3 = load i32, ptr addrspace(5) %arrayidx12
  %arrayidx13 = getelementptr inbounds i32, ptr addrspace(1) %out, i32 1
  store i32 %3, ptr addrspace(1) %arrayidx13
  ret void
}

define amdgpu_kernel void @explicit_default_workgroup_size(ptr addrspace(1) nocapture %out, ptr addrspace(1) nocapture %in) #1 {
; CHECK-LABEL: @explicit_default_workgroup_size(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[STACK:%.*]] = alloca [5 x i32], align 4, addrspace(5)
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr addrspace(1) [[IN:%.*]], align 4
; CHECK-NEXT:    [[ARRAYIDX1:%.*]] = getelementptr inbounds [5 x i32], ptr addrspace(5) [[STACK]], i32 0, i32 [[TMP0]]
; CHECK-NEXT:    store i32 4, ptr addrspace(5) [[ARRAYIDX1]], align 4
; CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds i32, ptr addrspace(1) [[IN]], i32 1
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr addrspace(1) [[ARRAYIDX2]], align 4
; CHECK-NEXT:    [[ARRAYIDX3:%.*]] = getelementptr inbounds [5 x i32], ptr addrspace(5) [[STACK]], i32 0, i32 [[TMP1]]
; CHECK-NEXT:    store i32 5, ptr addrspace(5) [[ARRAYIDX3]], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr addrspace(5) [[STACK]], align 4
; CHECK-NEXT:    store i32 [[TMP2]], ptr addrspace(1) [[OUT:%.*]], align 4
; CHECK-NEXT:    [[ARRAYIDX12:%.*]] = getelementptr inbounds [5 x i32], ptr addrspace(5) [[STACK]], i32 0, i32 1
; CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr addrspace(5) [[ARRAYIDX12]], align 4
; CHECK-NEXT:    [[ARRAYIDX13:%.*]] = getelementptr inbounds i32, ptr addrspace(1) [[OUT]], i32 1
; CHECK-NEXT:    store i32 [[TMP3]], ptr addrspace(1) [[ARRAYIDX13]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %stack = alloca [5 x i32], align 4, addrspace(5)
  %0 = load i32, ptr addrspace(1) %in, align 4
  %arrayidx1 = getelementptr inbounds [5 x i32], ptr addrspace(5) %stack, i32 0, i32 %0
  store i32 4, ptr addrspace(5) %arrayidx1, align 4
  %arrayidx2 = getelementptr inbounds i32, ptr addrspace(1) %in, i32 1
  %1 = load i32, ptr addrspace(1) %arrayidx2, align 4
  %arrayidx3 = getelementptr inbounds [5 x i32], ptr addrspace(5) %stack, i32 0, i32 %1
  store i32 5, ptr addrspace(5) %arrayidx3, align 4
  %2 = load i32, ptr addrspace(5) %stack, align 4
  store i32 %2, ptr addrspace(1) %out, align 4
  %arrayidx12 = getelementptr inbounds [5 x i32], ptr addrspace(5) %stack, i32 0, i32 1
  %3 = load i32, ptr addrspace(5) %arrayidx12
  %arrayidx13 = getelementptr inbounds i32, ptr addrspace(1) %out, i32 1
  store i32 %3, ptr addrspace(1) %arrayidx13
  ret void
}

attributes #0 = { "amdgpu-waves-per-eu"="1,1" }
attributes #1 = { "amdgpu-flat-work-group-size"="1,1024" }
